---
title: "LinkedList && HashTable"
categories:
  - LinkedList
  - HashTalbe
tags:
  - LinkedList
  - HashTalbe
---

1. LinkedList(연결리스트)  

	LinkedList(연결리스트)란 크기가 동적인 자료구조로 **노드**에 값을 넣어서 저장하고, 노드의 연결로 이루어진 자료구조이다.  

	여기서도 예를 들면 좋을 것 같다.  
	출석부에는 사람들의 이름이 리스트의 형태로 주욱 나열되어있다.(김영희, 김철수, 나코드...)  
	가나다순으로 정렬되어 있다고 가정하자.  
	1번에 있는 사람이 **head**이고, 제일 마지막번 사람이 **tail**이 된다.  
	만약 5번 사람을 찾고싶다면? 1번의 다음 다음 다음 다음번째 학생을 찾으면 될 것이다.  
	여기서 **다음을 찾으려면 next**를 사용하면 된다.(1번.next = 2번, 2번.next = 3번 ...)  
	마지막번째가 되면 next는 존재하지 않으므로 tail.next = null이 된다.  

	그런데 어느날 다른 사람이 새로 들어왔다. 그렇다면 추가는 어떻게 할 것인가?  
	처음에 넣을 수도 있고, 마지막에 넣을 수도 있고, 중간에 끼워 넣을 수도 있다.  
	처음에 넣으려면 새로운 값.next를 현재 head로 설정하면 되고, 마지막에 넣으려면 tail.next에 새로운 값을 넣으면 되고, 중간에 넣으려면 넣으려는 인덱스.next를 새로운 값으로 지정하고, 원래 있던 next값을 새로운 값의 next값으로 설정하면 된다.  

	그리고 어떤 사람이 나가게 되었다. 삭제는?  
	마찬가지로 처음을 삭제할 수도 있고, 마지막을 삭제할 수도 있고, 중간에 삭제할 수도 있다.  
	처음을 삭제하려면 head를 next의 것으로 바꾸면 되고, 마지막을 삭제하려면 그냥 삭제하면 되고, 중간에 삭제하려면 탐색하다가 다음 노드가 삭제할 노드면 현재 노드.next를 삭제할 노드.next로 바꾸면 된다.  

	지금 설명한 내용은 단일 연결리스트라서 next밖에 없지만, 이전 노드를 가리키는 prev도 존재하는 이중 연결리스트도 존재한다. 사용 방법은 똑같다.  

2. HashTable(해쉬테이블)  

	HashTable(해쉬테이블)은 키를 **해쉬함수를 통하여 변환**한 후에 bucket이라는 공간에 키, 값을 저장하는 자료구조이다.   

	예를 들어 어떤 수를 10으로 나누었을 때의 나머지로 해쉬를 하는 함수가 있다고 하자.  
	여기서 32라는 수가 들어오면 32는 10으로 나누었을 때의 나머지가 2이므로 2라는 키에 32라는 값을 넣게 된다.  
	하지만 여러번 반복하다보면 42, 52 등 같은 2라는 키에 들어가게 되는 경우가 생기게 된다.  
	이를 **해쉬 충돌(Hash collision)**이라고 한다.  
	어감이 부정적이듯이 충돌이 일어나지 않을수록 좋은 해쉬함수이다.  
	충돌이 찾아지면 성능을 떨어뜨리므로 해쉬함수를 잘 정의하여 충돌을 최소화 하는것이 성능 개선에 도움이 된다.  

	그렇다면 해쉬 충돌의 해결법은?  
	- 체이닝 기법: 버킷 내에 연결리스트를 할당하여, 버킷에 데이터를 삽입하다가 해쉬 충돌이 발생하면 연결리스트로 데이터를 연결하는 방법  
	- 개방 주소법: 해쉬 충돌이 일어나면 일단 다른 버킷에 데이터를 삽입하는 방법  
	이 방법에는 여러가지 방법이 많다. (선형 탐색, 제곱 탐색, 이중 해시 등등)  
