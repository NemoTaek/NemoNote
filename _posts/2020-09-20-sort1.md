---
title: "sort(1)"
tags:
  - 선택 정렬
  - 버블 정렬
  - 삽입 정렬
---

요즘 하루 일과를 시작하기 전에 1시간씩 간단한(?) 알고리즘 문제를 풀고 있다.  
오늘 문제를 하나 푸는데, 정렬에 관한 문제가 나와서 정렬에 대한 블로깅을 하려고 한다.  

우선 정렬의 종류에는 5가지 정도가 있다.  
`선택정렬, 버블정렬, 삽입정렬, 병합정렬, 퀵정렬`이 대표적이다.  

1. 선택 정렬  

    선택 정렬은 가장 큰 값이든 작은 값이든 찾아서 그 값을 맨 앞의 값과 교환해서 정렬하는 방법이다.  
    `[46, 29, 7, 22, 15, 95]` 가 있다고 하고 오름차순으로 정렬한다고 가정했을 때, 과정은 다음과 같다.  
  
    - 반복문으로 요소를 한바퀴 돌면서 가장 작은 값을 찾는다. => 7  
    - 그 값을 맨 앞의 값과 교환한다. => [7, 29, 46, 22, 15, 95]  
    - 정렬된 맨 앞의 값을 제외하고 이를 다시 반복한다.  
	<br>

	이를 코드로 표현하면 다음과 같다.  

	```
	function selectionSort(arr) {
		let minIndex, tmp;
		for(let i=0; i<arr.length-1; i++) {
			minIndex = i;
			// 가장 작은 값을 찾는 과정
			for(let j=i+1; j<arr.length; j++) {
				if(arr[j] < arr[minIndex]){
					minIdx = j;
				}
			}
			// 값 교환
			tmp = arr[minIndex];
			arr[minIndex] = arr[i];
			arr[i] = tmp;
		}
		return arr;
	}
	```

	2중 반복문을 사용하기 때문에 시간복잡도는 O(n^2)이 된다.  
	<br>
2. 버블 정렬  

    버블 정렬은 처음부터 2개의 값을 비교하면서 정렬하는 방법이다. 물론 한바퀴만에 정렬이 끝나지는 않기 때문에, 정렬이 될 때까지 반복을 해야한다.  
    역시 `[46, 29, 7, 22, 15, 95]` 가 있다고 하고 오름차순으로 정렬한다고 가정했을 때, 과정은 다음과 같다.  
  
	- 46과 29의 값을 비교하여 정렬한다. => [29, 46, 7, 22, 15, 95]  
	- 정렬된 46과 7의 값을 비교하여 정렬한다. => [29, 7, 46, 22, 15, 95]  
	- 반복하여 일단 한바퀴 돌며 정렬한다. (한바퀴의 결과값은 제알 마지막 인덱스에 저장) => [29, 7, 22, 15, 46, 95]  
	- 한바퀴만에 정렬이 끝나지 않기 때문에, 모든 정렬이 완료 될때까지 반복한다.  
	<br>

	이를 코드로 표현하면 다음과 같다.  

	```
	function bubbleSort(arr) {
		for(let i=0; i<arr.length-1; i++) {
			for(let j=0; j<arr.length-i-1; j++) {
				// 인접한 두 값을 비교하여 정렬이 필요하면 교환
				if(arr[j] > arr[j+1]) {
					let tmp = arr[j];
					arr[j] = arr[j+1];
					arr[j+1] = tmp;
				}
			}
		}
		return arr;
	}
	```

	이 역시도 2중 반복문을 사용하기 때문에 시간복잡도는 O(n^2)이 된다.  
	<br>
3. 삽입 정렬  

    삽입 정렬은 현재 인덱스의 값을 가지고 한바퀴 돌면서 정렬되어야 하는 위치에 삽입시키는 방법이다.  
    역시 `[46, 29, 7, 22, 15, 95]` 가 있다고 하고 오름차순으로 정렬한다고 가정했을 때, 과정은 다음과 같다.  
  
	- 46은 이전 요소가 없으므로 그냥 둔다.  
	- 29는 이전 요소(46)보다 작으므로 46 앞에 삽입한다. => [29, 46, 7, 22, 15, 95]
	- 7은 이전 요소(29, 46)중 가장 작으므로 가장 앞에 삽입한다. => [7, 29, 46, 22, 15, 95]
	- 22는 이전 요소(7, 29, 46)에서 7 다음에 올 수이므로 그에 맞게 삽입한다. => [7, 22, 29, 46, 15, 95]
	- 한바퀴 돌때까지 반복한다.  
	<br>

	이를 코드로 표현하면 다음과 같다.  
	
	```
	function insertionSort(arr) {
		for(let i=1; i<arr.length; i++) {
			// 현재 인덱스 값을 저장
			let index = arr[i];
			for(let j=i-1; j>=0; j--) {
				// 현재 인덱스의 이전 요소들과 비교하여 정렬이 필요하면 교환
				if(index < arr[j]) {
					let tmp = arr[j];
					arr[j] = arr[j+1];
					arr[j+1] = tmp;
				}
			}
		}
		return arr;
	}
	```

	이 역시도 2중 반복문을 사용하기 때문에 시간복잡도는 O(n^2)이 된다.  
    <br>

병합정렬과 퀵정렬은 위의 3개의 정렬과는 살짝 개념이 다르기 때문에 다음 포스트에서 이어서 작성하겠다.  
(힌트를 주자면 분할 정복 알고리즘)
